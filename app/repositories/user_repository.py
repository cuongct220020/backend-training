# app/repositories/user_repository.py
from datetime import datetime
from typing import Optional, Any

from pydantic import SecretStr
from sqlalchemy import select, func, update
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.user import User
from app.repositories import BaseRepository


class UserRepository(BaseRepository[User]):
    def __init__(self, session: AsyncSession):
        super().__init__(User, session)

    async def get_by_username(self, username: str) -> Optional[User]:
        """
        Fetch a user record by username (case-insensitive).
        Returns None if no user is found.
        """
        if not username:
            return None

        stmt = (
            select(self.model)
            .where(func.lower(self.model.username) == func.lower(username))
            .limit(1)
        )
        result = await self.session.execute(stmt)
        user = result.scalars().first()
        return user

    async def get_by_id(self, user_id: Any) -> Optional[User]:
        return await super().get_by_id(user_id)

    async def create_user(self, data: dict) -> User:
        """
        Create user instance and add to session.
        Note: hashed password should be provided in `data['password_hash']` by service.
        """
        user = self.model(**data)
        self.session.add(user)
        # optionally flush to populate autogenerated fields (id, created_at)
        await self.session.flush()
        return user

    async def update_user(self, user_id: Any, data: dict) -> Optional[User]:
        user = await self.get_by_id(user_id)
        if not user:
            return None
        for k, v in data.items():
            setattr(user, k, v)
        self.session.add(user)
        await self.session.flush()
        return user

    async def increment_failed_attempts(self, user_id: Any, by: int = 1) -> Optional[int]:
        """
        Increment failed_login_attempts and return new value.
        Use atomic update for safety under concurrency.
        """
        q = (
            update(self.model)
            .where(self.model.id == user_id)
            .values(failed_login_attempts=self.model.failed_login_attempts + by,
                    updated_at=func.now())
            .returning(self.model.failed_login_attempts)
        )
        result = await self.session.execute(q)
        row = result.first()
        await self.session.flush()
        return row[0] if row else None

    async def reset_failed_attempts(self, user_id: Any) -> None:
        q = (
            update(self.model)
            .where(self.model.id == user_id)
            .values(failed_login_attempts=0, updated_at=func.now())
        )
        await self.session.execute(q)
        await self.session.flush()

    async def lock_user(self, user_id: Any, until: Optional[datetime] = None) -> None:
        """Lock user account. Optionally set a lock expiration (if model supports it)."""
        values = {"is_locked": True, "updated_at": func.now()}
        if hasattr(self.model, "locked_until") and until is not None:
            values["locked_until"] = until
        q = update(self.model).where(self.model.id == user_id).values(**values)
        await self.session.execute(q)
        await self.session.flush()

    async def unlock_user(self, user_id: Any) -> None:
        values = {"is_locked": False, "failed_login_attempts": 0, "updated_at": func.now()}
        if hasattr(self.model, "locked_until"):
            values["locked_until"] = None
        q = update(self.model).where(self.model.id == user_id).values(**values)
        await self.session.execute(q)
        await self.session.flush()

    async def update_last_login(self, user_id: Any, when: Optional[datetime] = None) -> None:
        when = when or datetime.utcnow()
        q = update(self.model).where(self.model.id == user_id).values(last_login=when, updated_at=func.now())
        await self.session.execute(q)
        await self.session.flush()